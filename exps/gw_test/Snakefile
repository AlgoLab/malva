### TODO: make data available + rules to populate mid folder

configfile: "config.yaml"

import os

folds = config["resources"]["folds"]
files = config["resources"]["files"]
infos = config["resources"]["info"]

### Folds
root_fold = folds["root"]
malva_fold = folds["malva"]

in_fold = os.path.join(root_fold, folds["in"])
mid_fold = os.path.join(root_fold, folds["mid"])
out_fold = os.path.join(root_fold, folds["out"])

ref = os.path.join(in_fold, files["ref"])
in_vcf = os.path.join(in_fold, files["vcf"])
sample = os.path.join(mid_fold, files["sample"])
truth_vcf = os.path.join(mid_fold, files["truth_vcf"])

malva_ram = infos["malva_ram"]
ram_fold = str(malva_ram) + "G"

### Other paramters
ks_ = [27, 31, 35, 39, 43, 47] # Small k
dks = [2, 6, 12, 18] # delta_k

ks = []
Ks = []
for k in ks_:
    for dk in dks:
        ks.append(k)
        Ks.append(k+dk)

ks = [35]
Ks = [47]
Cs = [100, 150, 200, 250]

### Questa regola Ã¨ da sistemare (lo zip prende anche la c ora, quindi solo 4 jobs).
rule run:
    input:
        expand(os.path.join(out_fold, ram_fold, "happy", "k{k}.K{K}.c{c}.summary.csv"),
               # zip,
               k = ks,
               K = Ks,
               c = Cs)

rule kmc:
    input:
        sample = sample
    output:
        suf = os.path.join(out_fold, "KMC", "KMC.K{K}.kmc_suf")
    params:
        out_prefix = os.path.join(out_fold, "KMC", "KMC.K{K}"),
        tmp_fold = os.path.join(out_fold, "KMC", "KMC.K{K}_tmp"),
        K = "{K}"
    log:
        time = os.path.join(out_fold, "KMC", "KMC.K{K}.time"),
        out = os.path.join(out_fold, "KMC", "KMC.K{K}.log")
    shell:
        """
        mkdir -p {params.tmp_fold}
        /usr/bin/time -v -o {log.time} {malva_fold}/KMC/bin/kmc -m3 -t4 -k{params.K} {input.sample} {params.out_prefix} {params.tmp_fold} &> {log.out}
        rm -r {params.tmp_fold}
        """

rule malva:
    input:
        ref = ref,
        vcf = in_vcf,
        suf = os.path.join(out_fold, "KMC", "KMC.K{K}.kmc_suf")
    output:
        vcf = os.path.join(out_fold, ram_fold, "malva", "malva.k{k}.K{K}.c{c}.vcf")
    params:
        kmc_prefix = os.path.join(out_fold, "KMC", "KMC.K{K}"),
        k = "{k}",
        K = "{K}",
        c = "{c}"
    log:
        time = os.path.join(out_fold, ram_fold, "malva", "malva.k{k}.K{K}.c{c}.time"),
        out = os.path.join(out_fold, ram_fold, "malva", "malva.k{k}.K{K}.c{c}.log")
    shell:
        """
        /usr/bin/time -v -o {log.time} {malva_fold}/malva -k {params.k} -r {params.K} -n 150 -e 0.001 -p EUR -c {params.c} -b {malva_ram} {input.ref} {input.vcf} {params.kmc_prefix} > {output.vcf} 2> {log.out}
        """

rule index_ref:
    input:
        ref
    output:
        ref + ".fai"
    shell:
        """
        samtools faidx {input}
        """

rule clean_vcf:
    input:
        os.path.join(out_fold, ram_fold, "malva", "malva.k{k}.K{K}.c{c}.vcf")
    output:
        os.path.join(out_fold, ram_fold, "malva", "malva.k{k}.K{K}.c{c}.cvcf")
    shell:
        """
        bash {malva_fold}/exps/scripts/clean_vcf.sh {input} > {output}
        """

rule happy:
    input:
        ref_index = ref + ".fai",
        vcf = os.path.join(out_fold, ram_fold, "malva", "malva.k{k}.K{K}.c{c}.cvcf")
    output:
        csv = os.path.join(out_fold, ram_fold, "happy", "k{k}.K{K}.c{c}.summary.csv")
    params:
        ref = ref,
        truth_vcf = truth_vcf,
        out_prefix = os.path.join(out_fold, ram_fold, "happy", "k{k}.K{K}.c{c}")
    log:
        out = os.path.join(out_fold, ram_fold, "happy", "k{k}.K{K}.c{c}.log")
    shell:
        """
        bash {malva_fold}/exps/scripts/run_happy.sh {params.ref} {params.truth_vcf} {input.vcf} {params.out_prefix} &> {log.out}
        """
