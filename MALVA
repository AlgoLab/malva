#!/bin/bash
UNIQUE_ID=$$
BIN_NAME="malva"
EXECUTABLE="$(dirname $0)/${BIN_NAME}"
SCRIPT_NAME="$(basename $0)"
KMC_BIN="$(dirname $0)/KMC/bin/kmc"
DEFAULT_KSIZE=15
DEFAULT_REF_KSIZE=31
DEFAULT_COVERAGE=30
KMC_DEFAULT_DIR="./kmc_wk_dir_${UNIQUE_ID}"
USAGE=$'Usage: '"${SCRIPT_NAME}"' [-k ksize] [-m min_coverage] [-x max_coverage] [-l] <reference> <variants> <sample>
Preprocesses the VCF file and calls '"${BIN_NAME}"' and outputs a VCF containing the
known variants in <sample> to STDOUT.

Ideally this script will be depracated soon.

Arguments:
     -h              print this help and exit
     -k              kmers length (default:'"${DEFAULT_KSIZE}"')
     -r              reference kmers length (default:'"${DEFAULT_REF_KSIZE}"')
     -m              minimum coverage for filtering variants (default:'"${DEFAULT_COVERAGE}"')
     -x              maximum coverage for filtering variants (default: unlimited)
     -l              loose mode (default: false)
     -t              number of threads used by KMC (default: 1)
     -u              maximum (even) number of neighbouring variants considered
                     for each signature (default: 4)

Positional arguments:
     <reference>     reference file in FASTA/FASTQ format
     <variants>      variants file in VCF format
     <sample>        sample file in FASTA/FASTQ format'

reference=""
vcf_file=""
sample=""
k=${DEFAULT_KSIZE}
refk=${DEFAULT_REF_KSIZE}
min_coverage=${DEFAULT_COVERAGE}
max_coverage=251
max_combinations=4
MAX_MEMORY=3
loose_flag=""
kmc_out_file="kmc_${UNIQUE_ID}.kmercount"
threads_num=1

while getopts "r:t:m:x:k:u:hl" flag; do
    case "${flag}" in
        t) threads_num=${OPTARG}
	       ;;
        h) $(>&2 echo "${USAGE}")
           exit 1
           ;;
        m) min_coverage=${OPTARG}
           ;;
        x) max_coverage=${OPTARG}
           ;;
        k) k=${OPTARG}
           ;;
        r) refk=${OPTARG}
           ;;
        l) loose_flag="-l"
           ;;
        u) max_combinations=${OPTARG}
           ;;
    esac
done

if [[ $# -lt $((${OPTIND} + 2)) ]]
then
    (>&2 echo "ERROR: Wrong number of arguments.")
    (>&2 echo "")
    (>&2 echo "${USAGE}")
    exit 1
fi

reference=${@:$OPTIND:1}
vcf_file=${@:$OPTIND+1:1}
sample=${@:$OPTIND+2:1}

(>&2 echo "[${SCRIPT_NAME}] Process ID is ${UNIQUE_ID}")
(>&2 echo  "[${SCRIPT_NAME}] Running KMC")
mkdir -p ${KMC_DEFAULT_DIR}
\time -v -o /tmp/kmc-time-${UNIQUE_ID}.txt ${KMC_BIN} -cs251 -m${MAX_MEMORY} -k${refk} -t${threads_num} -fm ${sample} ${kmc_out_file} ${KMC_DEFAULT_DIR} > /dev/null

(>&2 echo  "[${SCRIPT_NAME}] Preprocessing VCF")
if [[ $vcf_file =~ \.gz$ ]]
then
    filteredVCF=$(dirname ${vcf_file})/$(basename ${vcf_file} .vcf.gz).${UNIQUE_ID}.filtered.vcf.gz
    zcat ${vcf_file} | cut -f 1-8 | gzip > ${filteredVCF}
else
    filteredVCF=$(dirname ${vcf_file})/$(basename ${vcf_file} .vcf).${UNIQUE_ID}.filtered.vcf
    cat ${vcf_file} | cut -f 1-8 > ${filteredVCF}
fi

(>&2 echo "[${SCRIPT_NAME}] Running ${BIN_NAME}")
\time -v -o /tmp/filter-time-${UNIQUE_ID}.txt ${EXECUTABLE} ${loose_flag} -t ${threads_num} -k ${k} -r ${refk} -c ${min_coverage} -x ${max_coverage} -u ${max_combinations} ${reference} ${filteredVCF} ${kmc_out_file}

(>&2 echo "[${SCRIPT_NAME}] Cleaning up")
rm ${filteredVCF}
rm -rf ${KMC_DEFAULT_DIR}
rm ${kmc_out_file}*

exit 0
